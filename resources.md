## Що таке `Resource` в Godot?

Перш за все, важливо розуміти сам клас `Resource`. В Godot, **`Resource`** — це базовий клас для всіх об'єктів, що зберігають дані. Подумайте про них як про "контейнери даних".

На відміну від `Node` (вузлів), які є активними учасниками дерева сцени (як `Sprite2D`, `Camera3D` або `CharacterBody3D`), ресурси є пасивними.

* **Приклади `Resource`:** `Texture`, `Script`, `Mesh`, `Animation`, `AudioStream`, `Font`.
* **Головна перевага:** Ресурси **підраховують посилання (reference-counted)**. Це означає, що Godot автоматично відстежує, скільки разів ресурс використовується. Він буде завантажений в пам'ять лише один раз і звільнений лише тоді, коли на нього більше ніхто не посилається. Це значно економить пам'ять.
* **Серіалізація:** Вони можуть бути легко збережені на диск (як файли `.res` або `.tres`) і завантажені назад.



---

## "Примітиви": Вбудовані Типи Даних (Core Types)

Те, що ви називаєте "примітивами", — це **вбудовані типи даних** Godot. Це не класи, що успадковують `Resource` (за винятком `Array` та `Dictionary`, які є особливими), а фундаментальні типи, які рушій використовує для всього.

Вони є цеглинками, з яких ви будуєте логіку в GDScript та налаштовуєте властивості в інспекторі.

### 1. Атомарні Типи (Atomic Types)

Це найпростіші одиниці даних:

* **`null`:** Означає "ніщо" або відсутність значення.
* **`bool`:** Логічний тип, може бути лише `true` (істина) або `false` (хиба).
* **`int`:** 64-бітне ціле число (наприклад, `10`, `-5`, `42`).
* **`float`:** 64-бітне число з плаваючою комою (наприклад, `10.5`, `0.01`, `3.14159`).

### 2. Рядки: `String` та `StringName`

Це одна з найважливіших відмінностей, яку варто розуміти:

* **`String`:** Стандартний рядок. Він містить текст (Unicode). `String` є **змінюваним** (immutable з копіюванням при записі), ідеально підходить для зберігання імен гравців, діалогів, тексту інтерфейсу тощо.
    ```gdscript
    var my_text: String = "Привіт, світе!"
    var score_text: String = "Рахунок: " + str(player_score)
    ```
* **`StringName`:** Це оптимізований, **незмінний (immutable)** рядок, призначений для унікальних імен. Коли ви створюєте `StringName`, Godot перевіряє, чи такий рядок вже існує в глобальному пулі. Якщо так, він просто дає вам посилання на нього.
    * **Навіщо?** Порівняння двох `StringName` — це надзвичайно швидка операція (порівняння двох вказівників), тоді як порівняння двох `String` вимагає перевірки кожного символу.
    * **Коли використовувати?** Завжди, коли ви посилаєтеся на щось за іменем, яке часто порівнюється:
        * Назви анімацій (`$AnimationPlayer.play("walk")`)
        * Назви вузлів (`get_node("Player")`)
        * Назви сигналів (`emit_signal("health_changed")`)
        * Імена в шейдерах (`shader_material.set_shader_parameter("albedo", color)`)

### 3. Векторні Типи (Vector Types)

Вони необхідні для 2D та 3D математики:

* **`Vector2` / `Vector2i`:** 2D-вектор (x, y) з `float` або `int` компонентів. Використовується для позицій, швидкостей, напрямків у 2D.
* **`Vector3` / `Vector3i`:** 3D-вектор (x, y, z). Використовується для позицій, напрямків, масштабування у 3D.
* **`Color`:** Колір RGBA (червоний, зелений, синій, альфа).
* **`Rect2`:** 2D-прямокутник (позиція + розмір).

### 4. Контейнери (Containers)

Це типи, призначені для зберігання інших типів даних.

#### `Array` (Масив)
Це гнучкий, динамічний список, який може містити **будь-які** типи даних (включаючи змішані, хоча це не рекомендується).

* **Синтаксис:** `[]`
* **Поведінка:** Масиви **передаються за посиланням**. Це означає, що якщо ви копіюєте масив, ви копіюєте лише посилання на нього. Зміна "копії" змінить і оригінал.
    ```gdscript
    var arr_a = [1, 2, 3]
    var arr_b = arr_a # arr_b тепер вказує на той самий масив
    arr_b.push_back(4)
    print(arr_a) # Виведе: [1, 2, 3, 4]
    
    # Щоб створити справжню копію:
    var arr_c = arr_a.duplicate()
    ```
* **Типізовані масиви:** Ви можете (і повинні) вказувати тип для кращої продуктивності та безпеки коду:
    ```gdscript
    var my_strings: Array[String] = ["А", "Б", "В"]
    var my_nodes: Array[Node] = [$Node1, $Node2]
    ```
* **Основні методи:** `append()` (додати в кінець), `push_back()` (те саме), `pop_back()` (видалити з кінця), `find()` (знайти індекс елемента), `sort()`.

#### `Dictionary` (Словник)
Контейнер, що зберігає пари "ключ-значення". Ключем може бути будь-який тип даних, як і значенням.

* **Синтаксис:** `{}`
* **Поведінка:** Словники, як і масиви, **завжди передаються за посиланням**. Використовуйте `duplicate()` для створення копії.
    ```gdscript
    var player_data = {
        "name": "Гравець1",
        "health": 100,
        "position": Vector2(50, 50)
    }
    
    print(player_data["name"]) # Виведе: Гравець1
    player_data["health"] = 80 # Зміна значення
    ```

#### `PackedArray` (Упаковані Масиви)
Це спеціалізовані, високооптимізовані масиви, призначені для зберігання **лише одного** конкретного атомарного типу. Вони значно швидші за звичайний `Array` і займають менше пам'яті, але є менш гнучкими.

* **Приклади:** `PackedStringArray`, `PackedInt32Array`, `PackedFloat64Array`, `PackedVector2Array`, `PackedColorArray`.
* **Поведінка:** На відміну від `Array` та `Dictionary`, упаковані масиви **передаються за значенням (copy-on-write)**. При копіюванні створюється новий незалежний екземпляр.
* **Коли використовувати?** Коли у вас є великий масив однотипних даних (наприклад, масив точок для `Line2D` (`PackedVector2Array`) або набір байтів (`PackedByteArray`)).

---

## Висновок: В чому різниця?

Найлегше думати про це так:

1.  **Вбудовані Типи (Core Types)** (ваші "примітиви", як-от `Vector2`, `Array`, `Dictionary`, `StringName`) — це **будівельні матеріали**.
2.  **`Resource`** (як-от `Texture`, `Mesh`, або ваш власний `class_name MyData extends Resource`) — це **будівля**, яку ви збудували з цих матеріалів.

Ви можете створити власний ресурс, який використовує ці примітиви:

```gdscript
# my_item_data.gd
@tool
class_name ItemData
extends Resource

@export var item_name: StringName
@export var description: String
@export var stats: Dictionary
@export var required_nodes: PackedStringArray