## Колізії в іграх

У захоплюючому світі відеоігор об’єкти не просто існують ізольовано; вони взаємодіють, зіштовхуються та впливають один на одного. Цей фундаментальний аспект, відомий як виявлення колізій (зіткнень), є тим, що оживляє віртуальні світи, дозволяючи всьому, від персонажа, що стрибає на платформу, до кулі, що влучає в ціль. Без колізій ігри були б статичними та млявими, а об’єкти проходили б крізь один одного, ніби привиди.

За своєю суттю, виявлення колізій — це процес визначення, чи два або більше об’єктів у світі гри перекриваються або торкаються. Щойно зіткнення виявлено, реакція на колізію диктує, що станеться далі — можливо, відскок, руйнування або запуск події. Ці дві концепції працюють пліч-о-пліч, щоб створити правдоподібний та захоплюючий ігровий процес.

### Основи: Хітбокси та Колайдери

Для ефективної обробки зіткнень ігри часто використовують спрощені представлення своїх об’єктів. Замість того, щоб використовувати складну 3D-модель персонажа, наприклад, гра може використовувати простішу фігуру, яку називають хітбокс (hitbox) або колайдер (collider). Це можуть бути базові геометричні форми, такі як сфери, коробки або капсули, які приблизно окреслюють фізичну присутність об’єкта.

Навіщо використовувати спрощені форми? Продуктивність! Перевірка перекриття між складними полігональними моделями є обчислювально дорогою. Використання простіших форм різко зменшує кількість необхідних обчислень, дозволяючи іграм працювати плавно навіть з багатьма об’єктами, що взаємодіють.

### Типи колізій

Виявлення колізій можна умовно поділити на кілька типів:

* Статичні проти Динамічних: Статичні колізії включають об’єкти, які не рухаються (наприклад, стіни або підлога), тоді як динамічні колізії включають рухомі об’єкти (наприклад, гравці, вороги або снаряди).

* Дискретні проти Безперервних: Дискретне виявлення колізій перевіряє зіткнення через певні проміжки часу. Якщо об’єкти рухаються дуже швидко, вони можуть "протунелювати" крізь один одного між перевірками. Безперервне виявлення колізій, з іншого боку, прогнозує шлях об’єктів, щоб запобігти тунелюванню, хоча воно є більш інтенсивним з точки зору обчислень.

Trigger проти Solid object:

Колізії-тригери: Вони виникають, коли об’єкти перекриваються, але фізичної реакції не відбувається. Натомість вони "запускають" подію. Уявіть, що ви заходите в зону, яка починає кат-сцену або підбирає предмет.

Тверді колізії: Це фізичні взаємодії, які ми зазвичай асоціюємо з зіткненням, де об’єкти не можуть проходити крізь один одного і чинять сили один на одного, що призводить до відскоку, зупинки або інших фізичних реакцій.

### Роль фізичного рушія

Сучасні ігрові рушії часто оснащені складними фізичними рушіями. Це спеціалізовані програмні компоненти, які обробляють усі аспекти фізичної симуляції, зокрема:

* Гравітація: Тягне об’єкти вниз.
* Тертя: Протидіє руху між поверхнями.
* Сили: Застосовує поштовхи або тягу до об’єктів.
* Виявлення колізій та реакція: Розрахунок ударів та їхніх наслідків.

Використання фізичного рушія значно спрощує роботу розробника, дозволяючи йому зосередитися на ігровій механіці, а не реалізовувати складні фізичні рівняння з нуля.

### Колізії в рушії Godot

Godot Engine надає надійну та гнучку систему для обробки колізій, що дозволяє розробникам легко реалізовувати інтерактивний ігровий процес. Підхід Godot зосереджений навколо вузлів ```CollisionObjects```(Об'єкти колізій) та ```CollisionShapes``` (Форми колізій).

```CollisionObjects``` (Об'єкти колізій)

У Godot будь-який вузол, який повинен виявляти або реагувати на зіткнення, успадковується від ```CollisionObject2D``` (для 2D-ігор) або ```CollisionObject3D``` (для 3D-ігор). Це базові класи для фізичних об’єктів у вашій грі. Найпоширеніші вузли, які ви зустрінете, що походять від них:

* ```Area2D``` / ```Area3D```: Використовуються для колізій-тригерів. Вони виявляють, коли інші ```CollisionObject``` входять або виходять з їхніх меж, але не зупиняють їхній рух. Вони ідеально підходять для виявлення, коли гравець входить у зону пошкодження, підбирає предмет або запускає подію.

* ```StaticBody2D``` / ```StaticBody3D```: Призначені для статичних об'єктів, які не рухаються або призначені бути нерухомими, як-от стіни, підлога або платформи. Вони забезпечують зіткнення для інших тіл, але самі не рухаються у відповідь на колізії.

*  ```RigidBody2D``` / ```RigidBody3D```: Представляють динамічні фізичні об'єкти, на які впливає фізика (гравітація, сили) та які реагують на зіткнення. Подумайте про м'яч, що відскакує, ящик, що падає, або персонажа у фізичному платформері. Їх можна налаштувати на різні режими:

    * Rigid (Жорсткий): Повністю симулюється фізичним рушієм.

    * Kinematic (Кінематичний): Керується кодом, але все ще реагує на колізії.

    * Character (Персонаж): Спеціалізований режим для персонажів гравця, часто використовується з move_and_slide() для плавного руху.

```KinematicBody2D``` / ```KinematicBody3D```: Це тіла, які ви маєте намір переміщати за допомогою коду. Хоча вони можуть виявляти зіткнення, вони не реагують на фізичні сили, такі як гравітація або імпульси, самі по собі. Натомість ви явно переміщуєте їх за допомогою таких функцій, як ```move_and_slide()``` (2D) або ```move_and_slide_with_snap()``` (3D), які обробляють вирішення колізій за вас. Вони ідеально підходять для персонажів гравців або інших об'єктів, де ви хочете мати точний контроль над рухом. (Примітка: У Godot 4 ```KinematicBody``` було замінено на ```CharacterBody```).

### CollisionShapes (Форми колізій)

Кожен ```CollisionObject``` потребує одного або декількох вузлів ```CollisionShape2D``` (для 2D) або ```CollisionShape3D``` (для 3D) як дочірніх. Вони визначають фактичні геометричні форми, що використовуються для виявлення зіткнень. Поширені форми включають:

* RectangleShape2D / BoxShape3D (Прякутник / Коробка)

* CircleShape2D / SphereShape3D (Коло / Сфера)

* CapsuleShape2D / CapsuleShape3D (Капсула)

* ConcavePolygonShape2D / ConcavePolygonShape3D (Увігнутий полігон, часто для складної геометрії рівня)

* ConvexPolygonShape2D / ConvexPolygonShape3D (Опуклий полігон, для складних опуклих форм)

Ви можете приєднати кілька форм колізій до одного CollisionObject, щоб створити більш складні межі зіткнення.